<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
<title>Chog Rush</title>
<!-- Social Preview Meta Tags -->
<meta property="og:title" content="Chog Rush üéÆ" />
<meta property="og:description" content="Collect MON, dodge obstacles, and chase glory in Chog Rush ‚Äî made by mi$fit." />
<meta property="og:image" content="https://chogrush.xyz/assets/preview_v2.jpg" />
<meta property="og:url" content="https://chogrush.xyz" />
<meta property="og:type" content="website" />

<!-- For better Telegram/WhatsApp/X previews -->
<meta name="twitter:card" content="summary_large_image" />
<meta name="twitter:title" content="Chog Rush üéÆ" />
<meta name="twitter:description" content="Collect MON, dodge obstacles, and chase glory in Chog Rush ‚Äî made by mi$fit." />
<meta name="twitter:image" content="https://chogrush.xyz/assets/preview_v2.jpg" />
<style>
  :root{--bg:#bcbcbc;--text:#072033}
  html,body{height:100%;margin:0;font-family:system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial;background:var(--bg);color:var(--text);-webkit-tap-highlight-color:transparent}
  canvas{display:block;width:100vw;height:100vh;background:var(--bg);touch-action:none}
  .overlay{position:fixed;inset:0;display:flex;align-items:center;justify-content:center;pointer-events:none}
  .panel{pointer-events:auto;background:rgba(255,255,255,0.97);border-radius:12px;padding:18px;max-width:760px;width:88%;box-shadow:0 8px 30px rgba(0,0,0,0.18);text-align:center}
  h1{margin:0 0 8px 0;font-size:34px}
  p.small{margin:6px 0;color:#334;font-size:14px}
  button{cursor:pointer;border:none;background:#072033;color:#fff;padding:10px 16px;border-radius:10px;font-weight:700}
  .controls{display:flex;gap:8px;justify-content:center;margin-top:10px}
  .hud{position:fixed;left:14px;top:14px;display:flex;gap:10px;align-items:center}
  .coinBox{display:flex;gap:8px;align-items:center;background:rgba(255,255,255,0.95);padding:8px 10px;border-radius:10px;font-weight:800;color:var(--text)}
  .livesBox{display:flex;gap:6px;align-items:center;padding:6px;background:rgba(255,255,255,0.95);border-radius:10px}
  .controlsBottom{position:fixed;bottom:14px;left:50%;transform:translateX(-50%);display:flex;gap:8px}
  .touchBtn{background:rgba(7,32,51,0.9);color:#fff;padding:10px 14px;border-radius:10px;font-weight:800;user-select:none;pointer-events:auto}
  .muted{opacity:0.7;font-size:13px;margin-top:8px}
  .start-bg{display:flex;flex-direction:column;align-items:center;justify-content:center;text-align:center}
  .start-bg img{max-width:70%;height:auto;display:block;margin:0 auto 18px auto}
  .icon-row{display:flex;justify-content:center;gap:20px;margin-bottom:12px}
  .icon-row img{width:40px;height:40px}
  @media(max-width:420px){ h1{font-size:28px} .start-bg img{max-width:90%;}}
</style>
</head>
<body>
<canvas id="gameCanvas" aria-label="Chog Rush game canvas"></canvas>

<!-- HUD -->
<div class="hud" aria-hidden="true">
  <div class="coinBox" id="coinBox">
    <img id="coinIcon" src="assets/coin.webp" width="28" height="28" style="display:none" alt="coin">
    <svg id="coinSVG" width="28" height="28" viewBox="0 0 24 24"><circle cx="12" cy="12" r="10" fill="#ffd700" stroke="#b88600" stroke-width="1"/><text x="12" y="16" font-size="10" text-anchor="middle" fill="#072033" font-weight="700">$</text></svg>
    <div id="coinCount">0</div>
  </div>
  <div class="livesBox" id="livesBox" style="margin-left:10px"></div>
</div>

<!-- Start Screen -->
<div id="startOverlay" class="overlay" style="display:flex;z-index:10">
  <div class="panel start-bg" role="dialog" aria-modal="true" style="padding:14px;">
    <!-- slightly smaller image so controls fit on short screens -->
    <img src="assets/start_bg.webp" alt="Chog Rush Start Image" id="startImage" style="max-width:65%; margin-bottom:10px;">

    <div class="icon-row" style="margin-bottom:8px;">
      <img src="assets/coin.webp" alt="MON Icon">
      <img src="assets/life.webp" alt="Health Icon">
    </div>

    <!-- Compact how-to + guide -->
    <p class="small" style="margin:4px 0 6px 0; text-align:left; font-size:14px;"><strong>How to play</strong>: use ‚Üê ‚Üí or A / D to move lanes. On mobile, tap left/right or swipe.</p>

    <div class="guide" style="max-width:92%; text-align:left; margin:0 auto 8px auto;">
      <ul style="margin:0; padding-left:18px; color:#334; font-size:13px; line-height:1.25;">
        <li><strong>MON</strong> = your score (collect as many as you can).</li>
        <li><strong>Chogs Chest</strong> = rare 5√ó MON boost.</li>
        <li>Avoid obstacles, each hit costs a life.</li>
      </ul>
    </div>

    <!-- Creator credit moved higher so it's visible before buttons -->
    <p class="small" style="margin:0 0 8px 0; font-size:13px; opacity:0.9; text-align:center;">
      Created by <strong>mi$fit</strong>
    </p>

    <!-- Buttons moved up slightly to avoid being cut off -->
    <div class="controls" style="margin-top:4px; margin-bottom:6px;">
      <button id="startButton">Start Game</button>
    </div>
  </div>
</div>

<!-- Game Over -->
<div id="gameOverOverlay" class="overlay" style="display:none;z-index:11">
  <div class="panel" role="dialog" aria-modal="true">
    <h1 id="goTitle">Game Over</h1>
    <div id="goImageWrap" style="margin:8px 0"></div>
    <p id="goMessage" class="small"></p>
    <p id="goMonText" class="small" style="margin-top:-16px;margin-bottom:12px;">
      MON collected: <strong id="goCoins">0</strong>
    </p>

    <div class="controls" style="margin-top: -10px; margin-bottom: 12px;">
      <button id="retryButton">Play Again</button>
      <button id="toStartButton" style="background:#eee;color:#072033">Back to Start</button>
    </div>
  </div>
</div>

<!-- Controls -->
<div class="controlsBottom" aria-hidden="true">
  <div id="touchLeft" class="touchBtn">‚óÄ</div>
  <div id="touchRight" class="touchBtn">‚ñ∂</div>
</div>

<!-- Audio -->
<audio id="audio_bgm1" src="sound/bgm1.mp3" preload="auto"></audio>
<audio id="audio_bgm2" src="sound/bgm2.mp3" preload="auto"></audio>
<audio id="audio_bgm3" src="sound/bgm3.mp3" preload="auto"></audio>
<audio id="audio_bgm4" src="sound/bgm4.mp3" preload="auto"></audio>
<audio id="audio_bgm5" src="sound/bgm5.mp3" preload="auto"></audio>
<audio id="audio_start" src="sound/start.mp3" loop></audio>
<audio id="audio_coin" src="sound/coin.mp3" preload="auto"></audio>
<audio id="audio_coinx5" src="sound/coinx5.mp3" preload="auto"></audio>
<audio id="audio_hit" src="sound/hit.mp3" preload="auto"></audio>
<audio id="audio_life" src="sound/life.mp3" preload="auto"></audio>
<audio id="audio_gameover" src="sound/gameover.mp3" preload="auto"></audio>

<script>
(() => {
// Canvas setup
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');

// Game state
let laneWidth, laneCenters;
let paused = false;

function resize() {
  canvas.width = window.innerWidth;
  canvas.height = window.innerHeight;
  laneWidth = canvas.width / 3;
  laneCenters = [laneWidth * 0.5, laneWidth * 1.5, laneWidth * 2.5];
  player.y = canvas.height - Math.min(140, canvas.height * 0.16);
  player.w = Math.min(120, canvas.width * 0.12);
  player.h = player.w;
  player.x = laneCenters[player.lane];
}
window.addEventListener('resize', resize);

// Player & Entities
const player = { lane: 1, x: 0, y: 0, w: 80, h: 80, targetX: 0, speedLerp: 0.22, bob: 0 };
let entities = [];
let coinCount = 0;
let lives = 3;
let running = false;
let gameOver = false;
let speed = 3;
const MAX_SPEED = 10;
const BASE_SPEED = 3;
let spawnTimer = 0;
let spawnInterval = 900;
let lastTime = performance.now();
let elapsed = 0;

// Difficulty
const DIFFICULTY_RAMP_MS = 180000;
const MIN_SPAWN_INTERVAL = 220;
const BASE_OBS_CHANCE = 0.20;
const MAX_OBS_CHANCE = 0.55;
const BASE_COINX5_CHANCE = 0.10;
const MIN_COINX5_CHANCE = 0.04;
const LIFE_POWER_CHANCE = 0.05;

// Hitbox scale
const hitbox = { player: 0.6, coin: 0.75, obs: 0.52 };

// Assets
const assets = {
  player: loadImage('assets/player.webp'),
  coin: loadImage('assets/coin.webp'),
  coinx5: loadImage('assets/coinx5.webp'),
  obstacle: loadImage('assets/obstacle.webp'),
  life: loadImage('assets/life.webp'),
  start_bg: loadImage('assets/start_bg.webp'),
  gameover_good: loadImage('assets/gameover_good.webp'),
  gameover_bad: loadImage('assets/gameover_bad.webp')
};
function loadImage(src) {
  const im = new Image();
  im.src = src;
  return im;
}

// Audio
const audio = {
  bgms: [
    document.getElementById('audio_bgm1'),
    document.getElementById('audio_bgm2'),
    document.getElementById('audio_bgm3'),
    document.getElementById('audio_bgm4'),
    document.getElementById('audio_bgm5')
  ],
  start: document.getElementById('audio_start'),
  coin: document.getElementById('audio_coin'),
  coinx5: document.getElementById('audio_coinx5'),
  hit: document.getElementById('audio_hit'),
  life: document.getElementById('audio_life'),
  gameover: document.getElementById('audio_gameover')
};
let currentBgm = null;
let currentBgmIndex = -1;
let muted = false;
function tryPlay(a) {
  if (!a || muted) return;
  try {
    // For short sound effects that are fired quickly, clone the element
    // so multiple copies can overlap (coin pickups, hits, life, coinx5).
    const shortFxIds = ['audio_coin', 'audio_coinx5', 'audio_hit', 'audio_life'];
    if (a.id && shortFxIds.includes(a.id)) {
      const clone = a.cloneNode(); // not appended, but playable
      clone.play().catch(() => {});
      // Optional: cleanup when finished (not strictly necessary)
      clone.addEventListener('ended', () => { try { clone.src = ''; } catch(e){} });
    } else {
      // For long sounds (bgm/gameover/start) use normal reset and play
      a.currentTime = 0;
      a.play().catch(() => {});
    }
  } catch (e) { /* swallow playback errors */ }
}
function tryStop(a) { if (!a) return; a.pause(); a.currentTime = 0; }

function playRandomBgm() {
  // Stop the current one
  if (currentBgm) {
    currentBgm.pause();
    currentBgm.currentTime = 0;
    currentBgm.onended = null;
  }

  // Build list of available (loaded) bgm elements
  const available = audio.bgms.filter(a => a && a.src && a.readyState > 0);
  if (available.length === 0) {
    // no loaded bgm available ‚Äî skip
    currentBgm = null;
    currentBgmIndex = -1;
    return;
  }

  // Pick a new random track from available, avoiding immediate repeat
  let newTrack;
  do {
    newTrack = available[Math.floor(Math.random() * available.length)];
  } while (newTrack === currentBgm && available.length > 1);

  currentBgm = newTrack;
  currentBgmIndex = audio.bgms.indexOf(currentBgm);

  if (!muted) {
    currentBgm.play().catch(() => {});
  }

  // When it ends, pick another random available one
  currentBgm.onended = playRandomBgm;
}


// DOM elements
const coinCountEl = document.getElementById('coinCount');
const livesBox = document.getElementById('livesBox');
const startOverlay = document.getElementById('startOverlay');
const gameOverOverlay = document.getElementById('gameOverOverlay');
const startButton = document.getElementById('startButton');
const retryButton = document.getElementById('retryButton');
const toStartButton = document.getElementById('toStartButton');
const goTitle = document.getElementById('goTitle');
const goMessage = document.getElementById('goMessage');
const goCoins = document.getElementById('goCoins');
const goImageWrap = document.getElementById('goImageWrap');

// Always show the coin icon instead of placeholder once loaded
const coinIconImg = document.getElementById('coinIcon');
const coinSVG = document.getElementById('coinSVG');
assets.coin.onload = () => {
  coinIconImg.style.display = 'block';
  coinSVG.style.display = 'none';
};

function updateHUD() {
  // Make sure the coin icon is always shown if the image is loaded
  if (assets.coin && assets.coin.complete && assets.coin.naturalWidth) {
    coinIconImg.style.display = 'block';
    coinSVG.style.display = 'none';
  } else {
    coinIconImg.style.display = 'none';
    coinSVG.style.display = 'block';
  }

  // Update coin count and lives
  coinCountEl.textContent = coinCount;
  livesBox.innerHTML = '';
  for (let i = 0; i < lives; i++) {
    const im = document.createElement('img');
    im.src = 'assets/life.webp';
    im.width = 28;
    im.height = 28;
    livesBox.appendChild(im);
  }
}

// Spawn entities
function spawnEntity(difficulty) {
  const r = Math.random();
  const obsChance = BASE_OBS_CHANCE + (MAX_OBS_CHANCE - BASE_OBS_CHANCE) * difficulty;
  const coinx5Chance = BASE_COINX5_CHANCE - (BASE_COINX5_CHANCE - MIN_COINX5_CHANCE) * difficulty;
  const lifeChance = LIFE_POWER_CHANCE * (1 - difficulty * 0.6);
  let type = 'coin';
  if (r < obsChance) type = 'obs';
  else if (r < obsChance + coinx5Chance) type = 'coinx5';
  else if (r < obsChance + coinx5Chance + lifeChance) type = 'life';
  const size = (type === 'coin' ? 36 : (type === 'coinx5' ? 56 : (type === 'life' ? 44 : 64)));
  const lane = Math.floor(Math.random() * 3);
  entities.push({ type, lane, x: laneCenters[lane], y: -size, size });
}

// Collision helper
function collided(e) {
  const px = player.x, py = player.y;
  const pr = Math.min(player.w, player.h) * 0.5 * hitbox.player;
  const er = e.size * 0.5 * (e.type === 'coin' ? hitbox.coin : (e.type === 'obs' ? hitbox.obs : 0.7));
  const dx = px - e.x, dy = py - e.y;
  return Math.hypot(dx, dy) < (pr + er);
}

// Controls
function moveLeft() { if (!running) return; player.lane = Math.max(0, player.lane - 1); player.targetX = laneCenters[player.lane]; }
function moveRight() { if (!running) return; player.lane = Math.min(2, player.lane + 1); player.targetX = laneCenters[player.lane]; }

window.addEventListener('keydown', (e) => {
  if (paused) return;
  if (e.key === 'ArrowLeft' || e.key === 'a' || e.key === 'A') moveLeft();
  if (e.key === 'ArrowRight' || e.key === 'd' || e.key === 'D') moveRight();
});

canvas.addEventListener('touchstart', (ev) => {
  if (paused) return;
  const t = ev.touches[0];
  const rect = canvas.getBoundingClientRect();
  const x = t.clientX - rect.left;
  if (x < rect.width / 2) moveLeft();
  else moveRight();
}, { passive: true });

// Update loop
function update(dt) {
  if (!running || paused) return;
  player.x += (player.targetX - player.x) * player.speedLerp;
  player.bob += dt * 0.008;
  elapsed += dt;
  const difficulty = Math.min(1, elapsed / DIFFICULTY_RAMP_MS);
  spawnInterval += ((900 - (900 - MIN_SPAWN_INTERVAL) * difficulty) - spawnInterval) * 0.02;
  spawnTimer += dt;
  if (spawnTimer > spawnInterval) { spawnEntity(difficulty); spawnTimer = 0; }
  speed = Math.min(MAX_SPEED, BASE_SPEED + (MAX_SPEED - BASE_SPEED) * difficulty);

  for (let i = entities.length - 1; i >= 0; i--) {
    const e = entities[i];
    e.y += speed * (e.type === 'obs' ? 1.08 : 1.0);
    if (collided(e)) {
      if (e.type === 'coin') { coinCount++; tryPlay(audio.coin); }
      else if (e.type === 'coinx5') { coinCount += 5; tryPlay(audio.coinx5); }
      else if (e.type === 'life') { lives = Math.min(3, lives + 1); tryPlay(audio.life); }
      else if (e.type === 'obs') { lives--; tryPlay(audio.hit); if (lives <= 0) { endGame(); return; } }
      entities.splice(i, 1);
      updateHUD();
      continue;
    }
    if (e.y - e.size > canvas.height + 50) entities.splice(i, 1);
  }
}

// End game
function endGame() {
  running = false;
  gameOver = true;
  if (currentBgm) {
  currentBgm.pause();
  currentBgm.currentTime = 0;
}
  tryPlay(audio.gameover);
  goCoins.textContent = coinCount;
  goImageWrap.innerHTML = '';
  goTitle.textContent = 'Game Over';
  gameOverOverlay.style.display = 'flex';

  // Randomized messages here; Part 3 replaces placeholders below
  goMessage.textContent = coinCount >= 250 ? 'You did great!' : 'Better luck next time!';
}
// --- MAIN LOOP ---
let rafId = null;
function loop(now) {
  const dt = now - lastTime;
  lastTime = now;
  if (!paused) {
    update(dt);
    draw();
  }
  rafId = requestAnimationFrame(loop);
}

// Draw everything
function draw() {
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  ctx.strokeStyle = 'rgba(0,0,0,0.06)';
  ctx.lineWidth = 2;
  for (let i = 1; i < 3; i++) {
    const x = i * (canvas.width / 3);
    ctx.beginPath();
    ctx.moveTo(x, 0);
    ctx.lineTo(x, canvas.height);
    ctx.stroke();
  }

  // Entities
  for (const e of entities) {
    if (e.type === 'coin' && assets.coin.complete) ctx.drawImage(assets.coin, e.x - e.size / 2, e.y - e.size / 2, e.size, e.size);
    else if (e.type === 'coinx5' && assets.coinx5.complete) ctx.drawImage(assets.coinx5, e.x - e.size / 2, e.y - e.size / 2, e.size, e.size);
    else if (e.type === 'life' && assets.life.complete) ctx.drawImage(assets.life, e.x - e.size / 2, e.y - e.size / 2, e.size, e.size);
    else if (e.type === 'obs' && assets.obstacle.complete) ctx.drawImage(assets.obstacle, e.x - e.size / 2, e.y - e.size / 2, e.size, e.size * 0.8);
  }

  // Player
  const bob = Math.sin(player.bob) * 4;
  ctx.save();
  ctx.translate(player.x, player.y + bob);
  if (assets.player.complete) ctx.drawImage(assets.player, -player.w / 2, -player.h / 2, player.w, player.h);
  else {
    ctx.fillStyle = '#3b82f6';
    ctx.fillRect(-player.w / 2, -player.h / 2, player.w, player.h);
  }
  ctx.restore();
}

// --- Start, Restart, Back ---
function startGame() {
  entities = [];
  coinCount = 0;
  lives = 3;
  running = true;
  gameOver = false;
  paused = false;
  elapsed = 0;
  spawnInterval = 900;
  spawnTimer = 0;
  speed = BASE_SPEED;
  player.lane = 1;
  player.targetX = laneCenters[player.lane];
  player.x = player.targetX;
  updateHUD();
  startOverlay.style.display = 'none';
  gameOverOverlay.style.display = 'none';
  tryStop(audio.start);
  playRandomBgm();
  lastTime = performance.now();
  if (rafId) cancelAnimationFrame(rafId);
  rafId = requestAnimationFrame(loop);
}

function restart() { startGame(); }

function toStart() {
  startOverlay.style.display = 'flex';
  gameOverOverlay.style.display = 'none';
  running = false;
  gameOver = false;
  paused = false;
  if (currentBgm) {
  currentBgm.pause();
  currentBgm.currentTime = 0;
}

}

// --- Initialize ---
resize();
player.x = laneCenters[player.lane];
updateHUD();

// --- PAUSE & MUTE CONTROLS ---
const muteBtn = document.createElement('button');
muteBtn.textContent = 'üîá';
Object.assign(muteBtn.style, {
  position: 'absolute',
  top: '10px',
  right: '10px',
  zIndex: '10',
  fontSize: '20px',
  background: 'rgba(0,0,0,0.4)',
  color: 'white',
  border: 'none',
  cursor: 'pointer',
  borderRadius: '8px'
});
document.body.appendChild(muteBtn);
muteBtn.style.display = 'none';

const pauseBtn = document.createElement('button');
pauseBtn.textContent = '‚è∏Ô∏è';
Object.assign(pauseBtn.style, {
  position: 'absolute',
  top: '10px',
  right: '60px',
  zIndex: '10',
  fontSize: '20px',
  background: 'rgba(0,0,0,0.4)',
  color: 'white',
  border: 'none',
  cursor: 'pointer',
  borderRadius: '8px',
  display: 'none'
});
document.body.appendChild(pauseBtn);

const pauseMenu = document.createElement('div');
Object.assign(pauseMenu.style, {
  position: 'absolute',
  top: '0',
  left: '0',
  width: '100%',
  height: '100%',
  background: 'rgba(0,0,0,0.6)',
  display: 'none',
  flexDirection: 'column',
  justifyContent: 'center',
  alignItems: 'center',
  color: 'white',
  zIndex: '20'
});
pauseMenu.innerHTML = `
  <h2>Paused</h2>
  <button id="resumeBtn">Resume</button>
  <button id="backToStartBtn">Back to Start</button>
`;
document.body.appendChild(pauseMenu);

// --- MUTE BUTTON (improved) ---
muteBtn.onclick = () => {
  muted = !muted;
  // update icon
  muteBtn.textContent = muted ? 'üîà' : 'üîá';

  // apply mute flag to all audio elements
  document.querySelectorAll('audio').forEach(a => {
    try { a.muted = muted; } catch(e){}
  });

  if (muted) {
    // when muting, pause the current bgm if playing
    if (currentBgm && !currentBgm.paused) {
      try { currentBgm.pause(); } catch(e){}
    }
  } else {
    // unmuting: if there is a currentBgm, resume it when appropriate
    if (currentBgm) {
      // if the game is running and not paused, resume bgm
      if (running && !paused) {
        try { currentBgm.play().catch(() => {}); } catch(e){}
      }
      // otherwise leave it paused until the game starts/resumes
    } else {
      // If no currentBgm selected but game is running, start shuffle
      if (running && !paused) {
        try { playRandomBgm(); } catch(e){}
      }
    }
  }
};

// --- PAUSE BUTTON ---
pauseBtn.onclick = () => {
  if (!paused) {
    paused = true;
    pauseMenu.style.display = 'flex';
    if (currentBgm) currentBgm.pause();
  }
};

// --- RESUME BUTTON ---
pauseMenu.querySelector('#resumeBtn').onclick = () => {
  paused = false;
  pauseMenu.style.display = 'none';
  if (currentBgm) currentBgm.play().catch(() => {});
};

// --- BACK TO START BUTTON ---
pauseMenu.querySelector('#backToStartBtn').onclick = () => {
  paused = false;
  pauseMenu.style.display = 'none';

  // Pause bgm
  if (currentBgm) {
    try { currentBgm.pause(); } catch(e){}
  }

  // Hide the controls so they are not interactive on the Start overlay
  try { muteBtn.style.display = 'none'; } catch(e){}
  try { pauseBtn.style.display = 'none'; } catch(e){}

  // Now go to start screen
  toStart();
};

// --- Show Pause when game starts ---
startButton.addEventListener('click', () => {
  muteBtn.style.display = 'block';
  pauseBtn.style.display = 'block';
  startGame();
});

retryButton.addEventListener('click', () => { pauseBtn.style.display = 'block'; restart(); });
toStartButton.addEventListener('click', () => {
  muteBtn.style.display = 'none';
  pauseBtn.style.display = 'none';
  toStart();
});


// --- FUNNY GAME OVER MESSAGES ---
const badMsgs = [
  "Bro‚Ä¶ even my grandma scores higher.",
  "That was embarrassing. Try again before anyone sees this.",
  "You call that a run?",
  "The Mon gods are disappointed.",
  "You‚Äôre playing like your phone‚Äôs on 1%.",
  "I‚Äôve seen bots do better.",
  "Congrats! You just set a new low score record.",
  "Bro blinked once and lost everything",
  "Imagine losing this early. Couldn‚Äôt be me.",
  "Even Chog is disappointed in you."
];

const goodMsgs = [
  "Okay okay‚Ä¶ you‚Äôre kinda cooking",
  "Alright grinder, I see you",
  "Not bad. Still broke tho.",
  "You‚Äôre touching greatness‚Ä¶ barely.",
  "Keep that up and Benja will notice you.",
  "You‚Äôre not him, but you‚Äôre getting there.",
  "W run. Almost made the leaderboard (in your dreams).",
  "Okay, don‚Äôt stop now mf, 1M MON or nothing!",
  "The streets are talking‚Ä¶ you might actually have skill.",
  "Maybe you‚Äôre not trash after all"
];

// --- Enhanced Game Over with images + messages ---
const originalEndGame = endGame;
endGame = function() {
  running = false;
  gameOver = true;
  if (currentBgm) {
  currentBgm.pause();
  currentBgm.currentTime = 0;
}
  tryPlay(audio.gameover);

  goCoins.textContent = coinCount;
  goImageWrap.innerHTML = '';
  goTitle.textContent = 'Game Over';
  gameOverOverlay.style.display = 'flex';

  // Choose random message set
  const msgs = coinCount >= 250 ? goodMsgs : badMsgs;
  goMessage.textContent = msgs[Math.floor(Math.random() * msgs.length)];
goMessage.style.fontWeight = '700';
goMessage.style.fontSize = '18px';
goMessage.style.color = '#072033';
goMessage.style.margin = '10px 0 12px 0';

  // Show corresponding image
  const img = new Image();
  img.src = coinCount >= 250 ? 'assets/gameover_good.webp' : 'assets/gameover_bad.webp';
  img.style.maxWidth = '60%';
  img.style.borderRadius = '12px';
  img.style.marginTop = '10px';
  goImageWrap.appendChild(img);
};


// Debug Access
window.ChogRush = { startGame, restart, toStart, getState: () => ({ coinCount, lives, entities, elapsed }) };

})();
</script>
</body>
</html>
