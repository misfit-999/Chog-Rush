<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
<title>Chog Rush</title>
<style>
  :root{--bg:#bcbcbc;--text:#072033}
  html,body{height:100%;margin:0;font-family:system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial;background:var(--bg);color:var(--text);-webkit-tap-highlight-color:transparent}
  canvas{display:block;width:100vw;height:100vh;background:var(--bg);touch-action:none}
  .overlay{position:fixed;inset:0;display:flex;align-items:center;justify-content:center;pointer-events:none}
  .panel{pointer-events:auto;background:rgba(255,255,255,0.97);border-radius:12px;padding:18px;max-width:760px;width:88%;box-shadow:0 8px 30px rgba(0,0,0,0.18);text-align:center}
  h1{margin:0 0 8px 0;font-size:34px}
  p.small{margin:6px 0;color:#334;font-size:14px}
  button{cursor:pointer;border:none;background:#072033;color:#fff;padding:10px 16px;border-radius:10px;font-weight:700}
  .controls{display:flex;gap:8px;justify-content:center;margin-top:10px}
  .hud{position:fixed;left:14px;top:14px;display:flex;gap:10px;align-items:center}
  .coinBox{display:flex;gap:8px;align-items:center;background:rgba(255,255,255,0.95);padding:8px 10px;border-radius:10px;font-weight:800;color:var(--text)}
  .livesBox{display:flex;gap:6px;align-items:center;padding:6px;background:rgba(255,255,255,0.95);border-radius:10px}
  .controlsBottom{position:fixed;bottom:14px;left:50%;transform:translateX(-50%);display:flex;gap:8px}
  .touchBtn{background:rgba(7,32,51,0.9);color:#fff;padding:10px 14px;border-radius:10px;font-weight:800;user-select:none;pointer-events:auto}
  .muted{opacity:0.7;font-size:13px;margin-top:8px}
  .start-bg{display:flex;flex-direction:column;align-items:center;justify-content:center;text-align:center}
  .start-bg img{max-width:70%;height:auto;display:block;margin:0 auto 18px auto}
  .icon-row{display:flex;justify-content:center;gap:20px;margin-bottom:12px}
  .icon-row img{width:40px;height:40px}
  @media(max-width:420px){ h1{font-size:28px} .start-bg img{max-width:90%;}}
</style>
</head>
<body>
<canvas id="gameCanvas" aria-label="Chog Rush game canvas"></canvas>

<!-- HUD -->
<div class="hud" aria-hidden="true">
  <div class="coinBox" id="coinBox">
    <img id="coinIcon" src="assets/coin.webp" width="28" height="28" style="display:none" alt="coin">
    <svg id="coinSVG" width="28" height="28" viewBox="0 0 24 24"><circle cx="12" cy="12" r="10" fill="#ffd700" stroke="#b88600" stroke-width="1"/><text x="12" y="16" font-size="10" text-anchor="middle" fill="#072033" font-weight="700">$</text></svg>
    <div id="coinCount">0</div>
  </div>
  <div class="livesBox" id="livesBox" style="margin-left:10px"></div>
</div>

<!-- Start Screen -->
<div id="startOverlay" class="overlay" style="display:flex;z-index:10">
  <div class="panel start-bg" role="dialog" aria-modal="true">
    <img src="assets/start_bg.webp" alt="Chog Rush Start Image" id="startImage">
    <div class="icon-row">
      <img src="assets/coin.webp" alt="Coin Icon">
      <img src="assets/life.webp" alt="Health Icon">
    </div>
    <p class="small">How to play: use ← → or A / D to move between lanes. On mobile, tap left/right or swipe.</p>
    <div class="controls">
      <button id="startButton">Start Game</button>
    </div>
  </div>
</div>

<!-- Game Over -->
<div id="gameOverOverlay" class="overlay" style="display:none;z-index:11">
  <div class="panel" role="dialog" aria-modal="true">
    <h1 id="goTitle">Game Over</h1>
    <div id="goImageWrap" style="margin:8px 0"></div>
    <p id="goMessage" class="small"></p>
    <p id="goMonText" class="small" style="margin-top:-16px;margin-bottom:12px;">
      MON collected: <strong id="goCoins">0</strong>
    </p>

    <div class="controls" style="margin-top: -10px; margin-bottom: 12px;">
      <button id="retryButton">Play Again</button>
      <button id="toStartButton" style="background:#eee;color:#072033">Back to Start</button>
    </div>
  </div>
</div>

<!-- Controls -->
<div class="controlsBottom" aria-hidden="true">
  <div id="touchLeft" class="touchBtn">◀</div>
  <div id="touchRight" class="touchBtn">▶</div>
</div>

<!-- Audio -->
<audio id="audio_bgm1" src="sound/bgm1.mp3"></audio>
<audio id="audio_bgm2" src="sound/bgm2.mp3"></audio>
<audio id="audio_bgm3" src="sound/bgm3.mp3"></audio>
<audio id="audio_bgm4" src="sound/bgm4.mp3"></audio>
<audio id="audio_bgm5" src="sound/bgm5.mp3"></audio>
<audio id="audio_start" src="sound/start.mp3" loop></audio>
<audio id="audio_coin" src="sound/coin.mp3"></audio>
<audio id="audio_coinx5" src="sound/coinx5.mp3"></audio>
<audio id="audio_hit" src="sound/hit.mp3"></audio>
<audio id="audio_life" src="sound/life.mp3"></audio>
<audio id="audio_gameover" src="sound/gameover.mp3"></audio>

<script>
(() => {
// Canvas setup
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');

// Game state
let laneWidth, laneCenters;
let paused = false;

function resize() {
  canvas.width = window.innerWidth;
  canvas.height = window.innerHeight;
  laneWidth = canvas.width / 3;
  laneCenters = [laneWidth * 0.5, laneWidth * 1.5, laneWidth * 2.5];
  player.y = canvas.height - Math.min(140, canvas.height * 0.16);
  player.w = Math.min(120, canvas.width * 0.12);
  player.h = player.w;
  player.x = laneCenters[player.lane];
}
window.addEventListener('resize', resize);

// Player & Entities
const player = { lane: 1, x: 0, y: 0, w: 80, h: 80, targetX: 0, speedLerp: 0.22, bob: 0 };
let entities = [];
let coinCount = 0;
let lives = 3;
let running = false;
let gameOver = false;
let speed = 3;
const MAX_SPEED = 10;
const BASE_SPEED = 3;
let spawnTimer = 0;
let spawnInterval = 900;
let lastTime = performance.now();
let elapsed = 0;

// Difficulty
const DIFFICULTY_RAMP_MS = 180000;
const MIN_SPAWN_INTERVAL = 220;
const BASE_OBS_CHANCE = 0.20;
const MAX_OBS_CHANCE = 0.55;
const BASE_COINX5_CHANCE = 0.10;
const MIN_COINX5_CHANCE = 0.04;
const LIFE_POWER_CHANCE = 0.05;

// Hitbox scale
const hitbox = { player: 0.6, coin: 0.75, obs: 0.52 };

// Assets
const assets = {
  player: loadImage('assets/player.webp'),
  coin: loadImage('assets/coin.webp'),
  coinx5: loadImage('assets/coinx5.webp'),
  obstacle: loadImage('assets/obstacle.webp'),
  life: loadImage('assets/life.webp'),
  start_bg: loadImage('assets/start_bg.webp'),
  gameover_good: loadImage('assets/gameover_good.webp'),
  gameover_bad: loadImage('assets/gameover_bad.webp')
};
function loadImage(src) {
  const im = new Image();
  im.src = src;
  return im;
}

// Audio
const audio = {
  bgms: [
    document.getElementById('audio_bgm1'),
    document.getElementById('audio_bgm2'),
    document.getElementById('audio_bgm3'),
    document.getElementById('audio_bgm4'),
    document.getElementById('audio_bgm5')
  ],
  start: document.getElementById('audio_start'),
  coin: document.getElementById('audio_coin'),
  coinx5: document.getElementById('audio_coinx5'),
  hit: document.getElementById('audio_hit'),
  life: document.getElementById('audio_life'),
  gameover: document.getElementById('audio_gameover')
};
let currentBgm = null;
let currentBgmIndex = -1;
let muted = false;
function tryPlay(a) { if (!a || muted) return; a.currentTime = 0; a.play().catch(() => {}); }
function tryStop(a) { if (!a) return; a.pause(); a.currentTime = 0; }

function playRandomBgm() {
  // Stop the current one
  if (currentBgm) {
    currentBgm.pause();
    currentBgm.currentTime = 0;
  }

  // Pick a new random index that’s different from the last
  let newIndex;
  do {
    newIndex = Math.floor(Math.random() * audio.bgms.length);
  } while (newIndex === currentBgmIndex && audio.bgms.length > 1);

  currentBgmIndex = newIndex;
  currentBgm = audio.bgms[newIndex];
  
  if (!muted) {
    currentBgm.play().catch(() => {});
  }

  // When it ends, automatically play another random one
  currentBgm.onended = playRandomBgm;
}


// DOM elements
const coinCountEl = document.getElementById('coinCount');
const livesBox = document.getElementById('livesBox');
const startOverlay = document.getElementById('startOverlay');
const gameOverOverlay = document.getElementById('gameOverOverlay');
const startButton = document.getElementById('startButton');
const retryButton = document.getElementById('retryButton');
const toStartButton = document.getElementById('toStartButton');
const goTitle = document.getElementById('goTitle');
const goMessage = document.getElementById('goMessage');
const goCoins = document.getElementById('goCoins');
const goImageWrap = document.getElementById('goImageWrap');

// Always show the coin icon instead of placeholder once loaded
const coinIconImg = document.getElementById('coinIcon');
const coinSVG = document.getElementById('coinSVG');
assets.coin.onload = () => {
  coinIconImg.style.display = 'block';
  coinSVG.style.display = 'none';
};

function updateHUD() {
  coinCountEl.textContent = coinCount;
  livesBox.innerHTML = '';
  for (let i = 0; i < lives; i++) {
    const im = document.createElement('img');
    im.src = 'assets/life.webp';
    im.width = 28;
    im.height = 28;
    livesBox.appendChild(im);
  }
}

// Spawn entities
function spawnEntity(difficulty) {
  const r = Math.random();
  const obsChance = BASE_OBS_CHANCE + (MAX_OBS_CHANCE - BASE_OBS_CHANCE) * difficulty;
  const coinx5Chance = BASE_COINX5_CHANCE - (BASE_COINX5_CHANCE - MIN_COINX5_CHANCE) * difficulty;
  const lifeChance = LIFE_POWER_CHANCE * (1 - difficulty * 0.6);
  let type = 'coin';
  if (r < obsChance) type = 'obs';
  else if (r < obsChance + coinx5Chance) type = 'coinx5';
  else if (r < obsChance + coinx5Chance + lifeChance) type = 'life';
  const size = (type === 'coin' ? 36 : (type === 'coinx5' ? 56 : (type === 'life' ? 44 : 64)));
  const lane = Math.floor(Math.random() * 3);
  entities.push({ type, lane, x: laneCenters[lane], y: -size, size });
}

// Collision helper
function collided(e) {
  const px = player.x, py = player.y;
  const pr = Math.min(player.w, player.h) * 0.5 * hitbox.player;
  const er = e.size * 0.5 * (e.type === 'coin' ? hitbox.coin : (e.type === 'obs' ? hitbox.obs : 0.7));
  const dx = px - e.x, dy = py - e.y;
  return Math.hypot(dx, dy) < (pr + er);
}

// Controls
function moveLeft() { if (!running) return; player.lane = Math.max(0, player.lane - 1); player.targetX = laneCenters[player.lane]; }
function moveRight() { if (!running) return; player.lane = Math.min(2, player.lane + 1); player.targetX = laneCenters[player.lane]; }

window.addEventListener('keydown', (e) => {
  if (paused) return;
  if (e.key === 'ArrowLeft' || e.key === 'a' || e.key === 'A') moveLeft();
  if (e.key === 'ArrowRight' || e.key === 'd' || e.key === 'D') moveRight();
});

canvas.addEventListener('touchstart', (ev) => {
  if (paused) return;
  const t = ev.touches[0];
  const rect = canvas.getBoundingClientRect();
  const x = t.clientX - rect.left;
  if (x < rect.width / 2) moveLeft();
  else moveRight();
}, { passive: true });

// Update loop
function update(dt) {
  if (!running || paused) return;
  player.x += (player.targetX - player.x) * player.speedLerp;
  player.bob += dt * 0.008;
  elapsed += dt;
  const difficulty = Math.min(1, elapsed / DIFFICULTY_RAMP_MS);
  spawnInterval += ((900 - (900 - MIN_SPAWN_INTERVAL) * difficulty) - spawnInterval) * 0.02;
  spawnTimer += dt;
  if (spawnTimer > spawnInterval) { spawnEntity(difficulty); spawnTimer = 0; }
  speed = Math.min(MAX_SPEED, BASE_SPEED + (MAX_SPEED - BASE_SPEED) * difficulty);

  for (let i = entities.length - 1; i >= 0; i--) {
    const e = entities[i];
    e.y += speed * (e.type === 'obs' ? 1.08 : 1.0);
    if (collided(e)) {
      if (e.type === 'coin') { coinCount++; tryPlay(audio.coin); }
      else if (e.type === 'coinx5') { coinCount += 5; tryPlay(audio.coinx5); }
      else if (e.type === 'life') { lives = Math.min(3, lives + 1); tryPlay(audio.life); }
      else if (e.type === 'obs') { lives--; tryPlay(audio.hit); if (lives <= 0) { endGame(); return; } }
      entities.splice(i, 1);
      updateHUD();
      continue;
    }
    if (e.y - e.size > canvas.height + 50) entities.splice(i, 1);
  }
}

// End game
function endGame() {
  running = false;
  gameOver = true;
  if (currentBgm) {
  currentBgm.pause();
  currentBgm.currentTime = 0;
}
  tryPlay(audio.gameover);
  goCoins.textContent = coinCount;
  goImageWrap.innerHTML = '';
  goTitle.textContent = 'Game Over';
  gameOverOverlay.style.display = 'flex';

  // Randomized messages here; Part 3 replaces placeholders below
  goMessage.textContent = coinCount >= 250 ? 'You did great!' : 'Better luck next time!';
}
// --- MAIN LOOP ---
let rafId = null;
function loop(now) {
  const dt = now - lastTime;
  lastTime = now;
  if (!paused) {
    update(dt);
    draw();
  }
  rafId = requestAnimationFrame(loop);
}

// Draw everything
function draw() {
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  ctx.strokeStyle = 'rgba(0,0,0,0.06)';
  ctx.lineWidth = 2;
  for (let i = 1; i < 3; i++) {
    const x = i * (canvas.width / 3);
    ctx.beginPath();
    ctx.moveTo(x, 0);
    ctx.lineTo(x, canvas.height);
    ctx.stroke();
  }

  // Entities
  for (const e of entities) {
    if (e.type === 'coin' && assets.coin.complete) ctx.drawImage(assets.coin, e.x - e.size / 2, e.y - e.size / 2, e.size, e.size);
    else if (e.type === 'coinx5' && assets.coinx5.complete) ctx.drawImage(assets.coinx5, e.x - e.size / 2, e.y - e.size / 2, e.size, e.size);
    else if (e.type === 'life' && assets.life.complete) ctx.drawImage(assets.life, e.x - e.size / 2, e.y - e.size / 2, e.size, e.size);
    else if (e.type === 'obs' && assets.obstacle.complete) ctx.drawImage(assets.obstacle, e.x - e.size / 2, e.y - e.size / 2, e.size, e.size * 0.8);
  }

  // Player
  const bob = Math.sin(player.bob) * 4;
  ctx.save();
  ctx.translate(player.x, player.y + bob);
  if (assets.player.complete) ctx.drawImage(assets.player, -player.w / 2, -player.h / 2, player.w, player.h);
  else {
    ctx.fillStyle = '#3b82f6';
    ctx.fillRect(-player.w / 2, -player.h / 2, player.w, player.h);
  }
  ctx.restore();
}

// --- Start, Restart, Back ---
function startGame() {
  entities = [];
  coinCount = 0;
  lives = 3;
  running = true;
  gameOver = false;
  paused = false;
  elapsed = 0;
  spawnInterval = 900;
  spawnTimer = 0;
  speed = BASE_SPEED;
  player.lane = 1;
  player.targetX = laneCenters[player.lane];
  player.x = player.targetX;
  updateHUD();
  startOverlay.style.display = 'none';
  gameOverOverlay.style.display = 'none';
  tryStop(audio.start);
  playRandomBgm();
  lastTime = performance.now();
  if (rafId) cancelAnimationFrame(rafId);
  rafId = requestAnimationFrame(loop);
}

function restart() { startGame(); }

function toStart() {
  startOverlay.style.display = 'flex';
  gameOverOverlay.style.display = 'none';
  running = false;
  gameOver = false;
  paused = false;
  if (currentBgm) {
  currentBgm.pause();
  currentBgm.currentTime = 0;
}

}

// --- Initialize ---
resize();
player.x = laneCenters[player.lane];
updateHUD();

// --- PAUSE & MUTE CONTROLS ---
const muteBtn = document.createElement('button');
muteBtn.textContent = '🔇';
Object.assign(muteBtn.style, {
  position: 'absolute',
  top: '10px',
  right: '10px',
  zIndex: '10',
  fontSize: '20px',
  background: 'rgba(0,0,0,0.4)',
  color: 'white',
  border: 'none',
  cursor: 'pointer',
  borderRadius: '8px'
});
document.body.appendChild(muteBtn);

const pauseBtn = document.createElement('button');
pauseBtn.textContent = '⏸️';
Object.assign(pauseBtn.style, {
  position: 'absolute',
  top: '10px',
  right: '60px',
  zIndex: '10',
  fontSize: '20px',
  background: 'rgba(0,0,0,0.4)',
  color: 'white',
  border: 'none',
  cursor: 'pointer',
  borderRadius: '8px',
  display: 'none'
});
document.body.appendChild(pauseBtn);

const pauseMenu = document.createElement('div');
Object.assign(pauseMenu.style, {
  position: 'absolute',
  top: '0',
  left: '0',
  width: '100%',
  height: '100%',
  background: 'rgba(0,0,0,0.6)',
  display: 'none',
  flexDirection: 'column',
  justifyContent: 'center',
  alignItems: 'center',
  color: 'white',
  zIndex: '20'
});
pauseMenu.innerHTML = `
  <h2>Paused</h2>
  <button id="resumeBtn">Resume</button>
  <button id="backToStartBtn">Back to Start</button>
`;
document.body.appendChild(pauseMenu);

// --- MUTE BUTTON ---
muteBtn.onclick = () => {
  muted = !muted;
  muteBtn.textContent = muted ? '🔈' : '🔇';
  document.querySelectorAll('audio').forEach(a => a.muted = muted);
};

// --- PAUSE BUTTON ---
pauseBtn.onclick = () => {
  if (!paused) {
    paused = true;
    pauseMenu.style.display = 'flex';
    if (currentBgm) currentBgm.pause();
  }
};

// --- RESUME BUTTON ---
pauseMenu.querySelector('#resumeBtn').onclick = () => {
  paused = false;
  pauseMenu.style.display = 'none';
  if (currentBgm) currentBgm.play().catch(() => {});
};

// --- BACK TO START BUTTON ---
pauseMenu.querySelector('#backToStartBtn').onclick = () => {
  paused = false;
  pauseMenu.style.display = 'none';
  if (currentBgm) currentBgm.pause();
  toStart(); // ✅ this correctly resets overlays
};

// --- Show Pause when game starts ---
startButton.addEventListener('click', () => {
  muteBtn.style.display = 'block';
  pauseBtn.style.display = 'block';
  startGame();
});

retryButton.addEventListener('click', () => { pauseBtn.style.display = 'block'; restart(); });
toStartButton.addEventListener('click', () => {
  muteBtn.style.display = 'none';
  pauseBtn.style.display = 'none';
  toStart();
});


// --- FUNNY GAME OVER MESSAGES ---
const badMsgs = [
  "Bro… even my grandma scores higher.",
  "That was embarrassing. Try again before anyone sees this.",
  "You call that a run?",
  "The Mon gods are disappointed.",
  "You’re playing like your phone’s on 1%.",
  "I’ve seen bots do better.",
  "Congrats! You just set a new low score record.",
  "Bro blinked once and lost everything",
  "Imagine losing this early. Couldn’t be me.",
  "Even Chog is disappointed in you."
];

const goodMsgs = [
  "Okay okay… you’re kinda cooking",
  "Alright grinder, I see you",
  "Not bad. Still broke tho.",
  "You’re touching greatness… barely.",
  "Keep that up and Benja will notice you.",
  "You’re not him, but you’re getting there.",
  "W run. Almost made the leaderboard (in your dreams).",
  "Okay, don’t stop now mf, 1M MON or nothing!",
  "The streets are talking… you might actually have skill.",
  "Maybe you’re not trash after all"
];

// --- Enhanced Game Over with images + messages ---
const originalEndGame = endGame;
endGame = function() {
  running = false;
  gameOver = true;
  if (currentBgm) {
  currentBgm.pause();
  currentBgm.currentTime = 0;
}
  tryPlay(audio.gameover);

  goCoins.textContent = coinCount;
  goImageWrap.innerHTML = '';
  goTitle.textContent = 'Game Over';
  gameOverOverlay.style.display = 'flex';

  // Choose random message set
  const msgs = coinCount >= 250 ? goodMsgs : badMsgs;
  goMessage.textContent = msgs[Math.floor(Math.random() * msgs.length)];
goMessage.style.fontWeight = '700';
goMessage.style.fontSize = '18px';
goMessage.style.color = '#072033';
goMessage.style.margin = '10px 0 12px 0';

  // Show corresponding image
  const img = new Image();
  img.src = coinCount >= 250 ? 'assets/gameover_good.webp' : 'assets/gameover_bad.webp';
  img.style.maxWidth = '60%';
  img.style.borderRadius = '12px';
  img.style.marginTop = '10px';
  goImageWrap.appendChild(img);
};


// Debug Access
window.ChogRush = { startGame, restart, toStart, getState: () => ({ coinCount, lives, entities, elapsed }) };

})();
</script>
</body>
</html>
