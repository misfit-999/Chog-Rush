<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
<title>Chog Rush</title>
<!-- Social Preview Meta Tags -->
<meta property="og:title" content="Chog Rush üéÆ" />
<meta property="og:description" content="Collect MON, dodge obstacles, and chase glory in Chog Rush ‚Äî made by mi$fit." />
<meta property="og:image" content="https://chogrush.xyz/assets/preview_v2.jpg" />
<meta property="og:url" content="https://chogrush.xyz" />
<meta property="og:type" content="website" />
<meta name="twitter:card" content="summary_large_image" />
<meta name="twitter:title" content="Chog Rush üéÆ" />
<meta name="twitter:description" content="Collect MON, dodge obstacles, and chase glory in Chog Rush ‚Äî made by mi$fit." />
<meta name="twitter:image" content="https://chogrush.xyz/assets/preview_v2.jpg" />
<style>
  :root{--bg:#bcbcbc;--text:#072033}
  html,body{height:100%;margin:0;font-family:system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial;background:var(--bg);color:var(--text);-webkit-tap-highlight-color:transparent}
  canvas{display:block;width:100vw;height:100vh;background:var(--bg);touch-action:none}
  .overlay{position:fixed;inset:0;display:flex;align-items:center;justify-content:center;pointer-events:none}
  .panel{pointer-events:auto;background:rgba(255,255,255,0.97);border-radius:12px;padding:18px;max-width:760px;width:88%;box-shadow:0 8px 30px rgba(0,0,0,0.18);text-align:center}
  h1{margin:0 0 8px 0;font-size:34px}
  p.small{margin:6px 0;color:#334;font-size:14px}
  button{cursor:pointer;border:none;background:#072033;color:#fff;padding:10px 16px;border-radius:10px;font-weight:700}
  .controls{display:flex;gap:8px;justify-content:center;margin-top:10px}
  .hud{position:fixed;left:14px;top:14px;display:flex;gap:10px;align-items:center}
  .coinBox{display:flex;gap:8px;align-items:center;background:rgba(255,255,255,0.95);padding:8px 10px;border-radius:10px;font-weight:800;color:var(--text)}
  .livesBox{display:flex;gap:6px;align-items:center;padding:6px;background:rgba(255,255,255,0.95);border-radius:10px}
  .controlsBottom{position:fixed;bottom:14px;left:50%;transform:translateX(-50%);display:flex;gap:8px}
  .touchBtn{background:rgba(7,32,51,0.9);color:#fff;padding:10px 14px;border-radius:10px;font-weight:800;user-select:none;pointer-events:auto}
  .muted{opacity:0.7;font-size:13px;margin-top:8px}
  .start-bg{display:flex;flex-direction:column;align-items:center;justify-content:center;text-align:center}
  .start-bg img{max-width:70%;height:auto;display:block;margin:0 auto 18px auto}
  .icon-row{display:flex;justify-content:center;gap:20px;margin-bottom:12px}
  .icon-row img{width:40px;height:40px}
  @media(max-width:420px){ h1{font-size:28px} .start-bg img{max-width:90%;}}

  /* ensure overlays are clickable when visible */
  #startOverlay, #gameOverOverlay { pointer-events: auto; }

  /* NEW: limit gameover image size so buttons stay visible */
  #goImageWrap img {
    display:block;
    margin: 10px auto 8px auto;
    max-width: 60%;
    max-height: 36vh;     /* <-- ensures image never grows too tall */
    width: auto;
    height: auto;
    border-radius: 12px;
    object-fit: contain;
  }

  /* NEW: position touch controls at screen edges */
  #touchLeft {
    position: fixed;
    left: 14px;
    bottom: 14px;
    transform: none;
    z-index: 50;
  }
  #touchRight {
    position: fixed;
    right: 14px;
    bottom: 14px;
    transform: none;
    z-index: 50;
  }

  /* ensure submit UI sits above overlay content */
  #submitWrap { z-index: 9999; position: relative; }

  /* make sure gameOver panel content can scroll on very short screens */
  #gameOverOverlay .panel { max-height: 85vh; overflow-y: auto; }
</style>
</head>
<body>
<canvas id="gameCanvas" aria-label="Chog Rush game canvas"></canvas>

<!-- HUD -->
<div class="hud" aria-hidden="true">
  <div class="coinBox" id="coinBox">
    <img id="coinIcon" src="assets/coin.webp" width="28" height="28" style="display:none" alt="coin">
    <svg id="coinSVG" width="28" height="28" viewBox="0 0 24 24"><circle cx="12" cy="12" r="10" fill="#ffd700" stroke="#b88600" stroke-width="1"/><text x="12" y="16" font-size="10" text-anchor="middle" fill="#072033" font-weight="700">MON</text></svg>
    <div id="coinCount">0</div>
  </div>
  <div class="livesBox" id="livesBox" style="margin-left:10px"></div>
</div>

<!-- Start Screen -->
<div id="startOverlay" class="overlay" style="display:flex;z-index:10">
  <!-- leaderboard box (inside start overlay, top-right) -->
  <div id="leaderboardBox" style="position:absolute; right:14px; top:14px; width:220px; background:rgba(255,255,255,0.95); padding:8px; border-radius:10px; text-align:left; font-size:13px; z-index:60;">
    <strong style="display:block;margin-bottom:6px;">Leaderboard</strong>
    <div id="leaderboardRows">Loading‚Ä¶</div>
    <div style="font-size:12px; opacity:0.8; margin-top:8px;">Submit to appear</div>
  </div>

  <div class="panel start-bg" role="dialog" aria-modal="true" style="padding:14px;">
    <img src="assets/start_bg.webp" alt="Chog Rush Start Image" id="startImage" style="max-width:65%; margin-bottom:10px;">
    <div class="icon-row" style="margin-bottom:8px;">
      <img src="assets/coin.webp" alt="MON Icon">
      <img src="assets/life.webp" alt="Health Icon">
    </div>

    <p class="small" style="margin:4px 0 6px 0; text-align:left; font-size:14px;"><strong>How to play</strong>: use ‚Üê ‚Üí or A / D to move lanes. On mobile, tap left/right or swipe.</p>

    <div class="guide" style="max-width:92%; text-align:left; margin:0 auto 8px auto;">
      <ul style="margin:0; padding-left:18px; color:#334; font-size:13px; line-height:1.25;">
        <li><strong>MON</strong> = your score (collect as many as you can).</li>
        <li><strong>Chogs Chest</strong> = rare 5√ó MON boost.</li>
        <li>Avoid obstacles, each hit costs a life.</li>
      </ul>
    </div>

    <p class="small" style="margin:0 0 8px 0; font-size:13px; opacity:0.9; text-align:center;">
      Created by <strong>mi$fit</strong>
    </p>

    <div class="controls" style="margin-top:4px; margin-bottom:6px;">
      <button id="startButton">Start Game</button>
    </div>
  </div>
</div>

<!-- Game Over -->
<div id="gameOverOverlay" class="overlay" style="display:none;z-index:60;pointer-events:auto;">
  <div class="panel" role="dialog" aria-modal="true" style="position:relative;overflow:visible;">
    <h1 id="goTitle">Game Over</h1>

    <div id="goImageWrap" style="margin:8px 0"></div>

    <p id="goMessage" class="small" style="font-weight:700;font-size:18px;color:#072033;margin:8px 0 6px 0;"></p>

    <p id="goMonText" class="small" style="margin:0 0 12px 0;font-weight:700;">
      MON collected: <strong id="goCoins">0</strong>
    </p>

    <!-- single submit UI inside panel (no duplicates) -->
    <div id="submitWrap" style="display:none; position:relative; z-index:9999; margin-bottom:10px;">
      <input id="leaderName" placeholder="Enter a name (2-20 chars)" maxlength="20"
             style="padding:8px;border-radius:8px;border:1px solid #ddd;width:58%;box-sizing:border-box;" />
      <button id="submitScoreBtn" style="margin-left:8px;background:#072033;color:#fff;padding:8px 10px;border-radius:8px;border:none;">
        Submit
      </button>
      <div id="submitMsg" style="font-size:13px;color:#333;margin-top:8px;display:inline-block;"></div>
    </div>

    <div class="controls" style="margin-top:0;margin-bottom:6px;display:flex;gap:8px;justify-content:center;">
      <button id="retryButton" style="padding:10px 14px">Play Again</button>
      <button id="toStartButton" style="background:#eee;color:#072033;padding:10px 14px">Back to Start</button>
    </div>
  </div>
</div>

<!-- Controls -->
<div aria-hidden="true">
  <div id="touchLeft" class="touchBtn" style="position:fixed;left:10px;bottom:14px;">‚óÄ</div>
  <div id="touchRight" class="touchBtn" style="position:fixed;right:10px;bottom:14px;">‚ñ∂</div>
</div>

<!-- Audio -->
<audio id="audio_bgm1" src="sound/bgm1.mp3" preload="auto"></audio>
<audio id="audio_bgm2" src="sound/bgm2.mp3" preload="auto"></audio>
<audio id="audio_bgm3" src="sound/bgm3.mp3" preload="auto"></audio>
<audio id="audio_bgm4" src="sound/bgm4.mp3" preload="auto"></audio>
<audio id="audio_bgm5" src="sound/bgm5.mp3" preload="auto"></audio>
<audio id="audio_start" src="sound/start.mp3" loop></audio>
<audio id="audio_coin" src="sound/coin.mp3" preload="auto"></audio>
<audio id="audio_coinx5" src="sound/coinx5.mp3" preload="auto"></audio>
<audio id="audio_hit" src="sound/hit.mp3" preload="auto"></audio>
<audio id="audio_life" src="sound/life.mp3" preload="auto"></audio>
<audio id="audio_gameover" src="sound/gameover.mp3" preload="auto"></audio>

<script>
(() => {
// Canvas setup
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');

// Game state
let laneWidth, laneCenters;
let paused = false;

function resize() {
  canvas.width = window.innerWidth;
  canvas.height = window.innerHeight;
  laneWidth = canvas.width / 3;
  laneCenters = [laneWidth * 0.5, laneWidth * 1.5, laneWidth * 2.5];
  player.y = canvas.height - Math.min(140, canvas.height * 0.16);
  player.w = Math.min(120, canvas.width * 0.12);
  player.h = player.w;
  player.x = laneCenters[player.lane];
}
window.addEventListener('resize', resize);

// Player & Entities
const player = { lane: 1, x: 0, y: 0, w: 80, h: 80, targetX: 0, speedLerp: 0.22, bob: 0 };
let entities = [];
let coinCount = 0;
let lives = 3;
let submittedThisRun = false;
let submitInProgress = false;
let running = false;
let gameOver = false;
let speed = 3;
const MAX_SPEED = 10;
const BASE_SPEED = 3;
let spawnTimer = 0;
let spawnInterval = 900;
let lastTime = performance.now();
let elapsed = 0;

// Difficulty
const DIFFICULTY_RAMP_MS = 180000;
const MIN_SPAWN_INTERVAL = 220;
const BASE_OBS_CHANCE = 0.20;
const MAX_OBS_CHANCE = 0.55;
const BASE_COINX5_CHANCE = 0.10;
const MIN_COINX5_CHANCE = 0.04;
const LIFE_POWER_CHANCE = 0.05;

// Hitbox scale
const hitbox = { player: 0.6, coin: 0.75, obs: 0.52 };

// Assets
const assets = {
  player: loadImage('assets/player.webp'),
  coin: loadImage('assets/coin.webp'),
  coinx5: loadImage('assets/coinx5.webp'),
  obstacle: loadImage('assets/obstacle.webp'),
  life: loadImage('assets/life.webp'),
  start_bg: loadImage('assets/start_bg.webp'),
  gameover_good: loadImage('assets/gameover_good.webp'),
  gameover_bad: loadImage('assets/gameover_bad.webp')
};
function loadImage(src) {
  const im = new Image();
  im.src = src;
  return im;
}

// Audio
const audio = {
  bgms: [
    document.getElementById('audio_bgm1'),
    document.getElementById('audio_bgm2'),
    document.getElementById('audio_bgm3'),
    document.getElementById('audio_bgm4'),
    document.getElementById('audio_bgm5')
  ],
  start: document.getElementById('audio_start'),
  coin: document.getElementById('audio_coin'),
  coinx5: document.getElementById('audio_coinx5'),
  hit: document.getElementById('audio_hit'),
  life: document.getElementById('audio_life'),
  gameover: document.getElementById('audio_gameover')
};
let currentBgm = null;
let currentBgmIndex = -1;
let muted = false;
function tryPlay(a) {
  if (!a || muted) return;
  try {
    const shortFxIds = ['audio_coin', 'audio_coinx5', 'audio_hit', 'audio_life'];
    if (a.id && shortFxIds.includes(a.id)) {
      const clone = a.cloneNode();
      clone.play().catch(() => {});
      clone.addEventListener('ended', () => { try { clone.src = ''; } catch(e){} });
    } else {
      a.currentTime = 0;
      a.play().catch(() => {});
    }
  } catch (e) { /* swallow playback errors */ }
}
function tryStop(a) { if (!a) return; a.pause(); a.currentTime = 0; }

function playRandomBgm() {
  if (currentBgm) {
    currentBgm.pause();
    currentBgm.currentTime = 0;
    currentBgm.onended = null;
  }

  const available = audio.bgms.filter(a => a && a.src && a.readyState > 0);
  if (available.length === 0) {
    currentBgm = null;
    currentBgmIndex = -1;
    return;
  }

  let newTrack;
  do {
    newTrack = available[Math.floor(Math.random() * available.length)];
  } while (newTrack === currentBgm && available.length > 1);

  currentBgm = newTrack;
  currentBgmIndex = audio.bgms.indexOf(currentBgm);

  if (!muted) {
    currentBgm.play().catch(() => {});
  }

  currentBgm.onended = playRandomBgm;
}

// DOM elements
const coinCountEl = document.getElementById('coinCount');
const livesBox = document.getElementById('livesBox');
const startOverlay = document.getElementById('startOverlay');
const gameOverOverlay = document.getElementById('gameOverOverlay');
const startButton = document.getElementById('startButton');
const retryButton = document.getElementById('retryButton');
const toStartButton = document.getElementById('toStartButton');
const goTitle = document.getElementById('goTitle');
const goMessage = document.getElementById('goMessage');
const goCoins = document.getElementById('goCoins');
const goImageWrap = document.getElementById('goImageWrap');

// show coin icon when ready
const coinIconImg = document.getElementById('coinIcon');
const coinSVG = document.getElementById('coinSVG');
assets.coin.onload = () => {
  coinIconImg.style.display = 'block';
  coinSVG.style.display = 'none';
};

function updateHUD() {
  if (assets.coin && assets.coin.complete && assets.coin.naturalWidth) {
    coinIconImg.style.display = 'block';
    coinSVG.style.display = 'none';
  } else {
    coinIconImg.style.display = 'none';
    coinSVG.style.display = 'block';
  }

  coinCountEl.textContent = coinCount;
  livesBox.innerHTML = '';
  for (let i = 0; i < lives; i++) {
    const im = document.createElement('img');
    im.src = 'assets/life.webp';
    im.width = 28;
    im.height = 28;
    livesBox.appendChild(im);
  }
}

// Spawn entities
function spawnEntity(difficulty) {
  const r = Math.random();
  const obsChance = BASE_OBS_CHANCE + (MAX_OBS_CHANCE - BASE_OBS_CHANCE) * difficulty;
  const coinx5Chance = BASE_COINX5_CHANCE - (BASE_COINX5_CHANCE - MIN_COINX5_CHANCE) * difficulty;
  const lifeChance = LIFE_POWER_CHANCE * (1 - difficulty * 0.6);
  let type = 'coin';
  if (r < obsChance) type = 'obs';
  else if (r < obsChance + coinx5Chance) type = 'coinx5';
  else if (r < obsChance + coinx5Chance + lifeChance) type = 'life';
  const size = (type === 'coin' ? 36 : (type === 'coinx5' ? 56 : (type === 'life' ? 44 : 64)));
  const lane = Math.floor(Math.random() * 3);
  entities.push({ type, lane, x: laneCenters[lane], y: -size, size });
}

// Collision helper
function collided(e) {
  const px = player.x, py = player.y;
  const pr = Math.min(player.w, player.h) * 0.5 * hitbox.player;
  const er = e.size * 0.5 * (e.type === 'coin' ? hitbox.coin : (e.type === 'obs' ? hitbox.obs : 0.7));
  const dx = px - e.x, dy = py - e.y;
  return Math.hypot(dx, dy) < (pr + er);
}

// Controls
function moveLeft(){
  if(!running) return;
  player.lane = Math.max(0, player.lane-1);
  player.targetX = laneCenters[player.lane];
  recordMove();
}
function moveRight(){
  if(!running) return;
  player.lane = Math.min(2, player.lane+1);
  player.targetX = laneCenters[player.lane];
  recordMove();
}

window.addEventListener('keydown', (e) => {
  if (paused) return;
  if (e.key === 'ArrowLeft' || e.key === 'a' || e.key === 'A') moveLeft();
  if (e.key === 'ArrowRight' || e.key === 'd' || e.key === 'D') moveRight();
});

canvas.addEventListener('touchstart', (ev) => {
  if (paused) return;
  const t = ev.touches[0];
  const rect = canvas.getBoundingClientRect();
  const x = t.clientX - rect.left;
  if (x < rect.width / 2) moveLeft();
  else moveRight();
}, { passive: true });

// Update loop
function update(dt) {
  if (!running || paused) return;
  player.x += (player.targetX - player.x) * player.speedLerp;
  player.bob += dt * 0.008;
  elapsed += dt;
  const difficulty = Math.min(1, elapsed / DIFFICULTY_RAMP_MS);
  spawnInterval += ((900 - (900 - MIN_SPAWN_INTERVAL) * difficulty) - spawnInterval) * 0.02;
  spawnTimer += dt;
  if (spawnTimer > spawnInterval) { spawnEntity(difficulty); spawnTimer = 0; }
  speed = Math.min(MAX_SPEED, BASE_SPEED + (MAX_SPEED - BASE_SPEED) * difficulty);

  for (let i = entities.length - 1; i >= 0; i--) {
    const e = entities[i];
    e.y += speed * (e.type === 'obs' ? 1.08 : 1.0);
    if (collided(e)) {
      if (e.type === 'coin') { coinCount++; tryPlay(audio.coin); }
      else if (e.type === 'coinx5') { coinCount += 5; tryPlay(audio.coinx5); }
      else if (e.type === 'life') { lives = Math.min(3, lives + 1); tryPlay(audio.life); }
      else if (e.type === 'obs') { lives--; tryPlay(audio.hit); if (lives <= 0) { endGame(); return; } }
      entities.splice(i, 1);
      updateHUD();
      continue;
    }
    if (e.y - e.size > canvas.height + 50) entities.splice(i, 1);
  }
}

// --- FUNNY GAME OVER MESSAGES ---
const badMsgs = [
  "Bro‚Ä¶ even my grandma scores higher.",
  "That was embarrassing. Try again before anyone sees this.",
  "You call that a run?",
  "The Mon gods are disappointed.",
  "You‚Äôre playing like your phone‚Äôs on 1%.",
  "I‚Äôve seen bots do better.",
  "Congrats! You just set a new low score record.",
  "Bro blinked once and lost everything",
  "Imagine losing this early. Couldn‚Äôt be me.",
  "Even Chog is disappointed in you."
];

const goodMsgs = [
  "Okay okay‚Ä¶ you‚Äôre kinda cooking",
  "Alright grinder, I see you",
  "Not bad. Still broke tho.",
  "You‚Äôre touching greatness‚Ä¶ barely.",
  "Keep that up and Benja will notice you.",
  "You‚Äôre not him, but you‚Äôre getting there.",
  "W run. Almost made the leaderboard (in your dreams).",
  "Okay, don‚Äôt stop now mf, 1M MON or nothing!",
  "The streets are talking‚Ä¶ you might actually have skill.",
  "Maybe you‚Äôre not trash after all"
];

// End game (clean, single implementation)
let endGame; // declare so we can assign
endGame = function () {
  // stop the run
  running = false;
  gameOver = true;

  // stop bgm if playing
  if (currentBgm) {
    try { currentBgm.pause(); currentBgm.currentTime = 0; currentBgm.onended = null; } catch(e){}
  }

  // play gameover sound
  tryPlay(audio.gameover);

  // update final score
  goCoins.textContent = coinCount;

  // clear any previous image/message
  goImageWrap.innerHTML = '';
  goMessage.textContent = '';

  // show the overlay
  goTitle.textContent = "Game Over";
  gameOverOverlay.style.display = 'flex';

  // choose message list and pick random
  const msgs = (typeof coinCount === 'number' && coinCount >= 250) ? goodMsgs : badMsgs;
  const chosen = msgs[Math.floor(Math.random() * msgs.length)];

  // apply message styling + text
  goMessage.textContent = chosen;
  goMessage.style.fontWeight = '700';
  goMessage.style.fontSize = '18px';
  goMessage.style.color = '#072033';
  goMessage.style.margin = '10px 0 12px 0';

  // append corresponding image (good / bad)
  const img = new Image();
  img.src = (typeof coinCount === 'number' && coinCount >= 250) ? 'assets/gameover_good.webp' : 'assets/gameover_bad.webp';
  img.style.maxWidth = '60%';
  img.style.borderRadius = '12px';
  img.style.marginTop = '10px';
  // NEW: limit height so buttons remain visible
  img.style.maxHeight = '36vh';
  img.style.objectFit = 'contain';
  img.onload = () => { /* nothing extra needed, it will display */ };
  img.onerror = () => { /* silently fail if image missing */ };
  goImageWrap.appendChild(img);

  // show submit UI inside the Game Over panel (only if not submitted this run)
  try {
    const wrap = document.getElementById('submitWrap');
    if (wrap) {
      if (!submittedThisRun) {
        wrap.style.display = 'block';
        wrap.style.zIndex = '999999';
        // focus the name field for convenience
        try { document.getElementById('leaderName').focus(); } catch(e){}
      } else {
        wrap.style.display = 'none';
      }
    }
  } catch(e){}

  // ensure Play Again / Back buttons are visible (in case of small screens)
  try {
    document.getElementById('retryButton').style.display = 'inline-block';
    document.getElementById('toStartButton').style.display = 'inline-block';
  } catch(e){}
};

// MAIN LOOP
let rafId = null;
function loop(now) {
  const dt = now - lastTime;
  lastTime = now;
  if (!paused) {
    update(dt);
    draw();
  }
  rafId = requestAnimationFrame(loop);
}

// Draw everything
function draw() {
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  ctx.strokeStyle = 'rgba(0,0,0,0.06)';
  ctx.lineWidth = 2;
  for (let i = 1; i < 3; i++) {
    const x = i * (canvas.width / 3);
    ctx.beginPath();
    ctx.moveTo(x, 0);
    ctx.lineTo(x, canvas.height);
    ctx.stroke();
  }

  // Entities
  for (const e of entities) {
    if (e.type === 'coin' && assets.coin.complete) ctx.drawImage(assets.coin, e.x - e.size / 2, e.y - e.size / 2, e.size, e.size);
    else if (e.type === 'coinx5' && assets.coinx5.complete) ctx.drawImage(assets.coinx5, e.x - e.size / 2, e.y - e.size / 2, e.size, e.size);
    else if (e.type === 'life' && assets.life.complete) ctx.drawImage(assets.life, e.x - e.size / 2, e.y - e.size / 2, e.size, e.size);
    else if (e.type === 'obs' && assets.obstacle.complete) ctx.drawImage(assets.obstacle, e.x - e.size / 2, e.y - e.size / 2, e.size, e.size * 0.8);
  }

  // Player
  const bob = Math.sin(player.bob) * 4;
  ctx.save();
  ctx.translate(player.x, player.y + bob);
  if (assets.player.complete) ctx.drawImage(assets.player, -player.w / 2, -player.h / 2, player.w, player.h);
  else {
    ctx.fillStyle = '#3b82f6';
    ctx.fillRect(-player.w / 2, -player.h / 2, player.w, player.h);
  }
  ctx.restore();
}

// Start, Restart, Back
function startGame() {
  entities = [];
  coinCount = 0;
  lives = 3;
  running = true;
  gameOver = false;
  paused = false;
  elapsed = 0;
  spawnInterval = 900;
  spawnTimer = 0;
  speed = BASE_SPEED;
  player.lane = 1;
  player.targetX = laneCenters[player.lane];
  player.x = player.targetX;
  updateHUD();
  startOverlay.style.display = 'none';
  gameOverOverlay.style.display = 'none';
  tryStop(audio.start);
  playRandomBgm();
  lastTime = performance.now();
  if (rafId) cancelAnimationFrame(rafId);
  rafId = requestAnimationFrame(loop);
}

function restart() { startGame(); }

function toStart() {
  startOverlay.style.display = 'flex';
  gameOverOverlay.style.display = 'none';
  running = false;
  gameOver = false;
  paused = false;
  loadLeaderboard();
  if (currentBgm) {
    currentBgm.pause();
    currentBgm.currentTime = 0;
  }
  // reset submit UI for next run
  resetSubmitStateForNewRun();
}

// Initialize
resize();
player.x = laneCenters[player.lane];
updateHUD();

// Pause & mute controls (created programmatically)
const muteBtn = document.createElement('button');
muteBtn.textContent = 'üîá';
Object.assign(muteBtn.style, {
  position: 'absolute', top: '10px', right: '10px', zIndex: '10', fontSize: '20px',
  background: 'rgba(0,0,0,0.4)', color: 'white', border: 'none', cursor: 'pointer', borderRadius: '8px'
});
document.body.appendChild(muteBtn);
muteBtn.style.display = 'none';

const pauseBtn = document.createElement('button');
pauseBtn.textContent = '‚è∏Ô∏è';
Object.assign(pauseBtn.style, {
  position: 'absolute', top: '10px', right: '60px', zIndex: '10', fontSize: '20px',
  background: 'rgba(0,0,0,0.4)', color: 'white', border: 'none', cursor: 'pointer', borderRadius: '8px',
  display: 'none'
});
document.body.appendChild(pauseBtn);

const pauseMenu = document.createElement('div');
Object.assign(pauseMenu.style, {
  position: 'absolute', top: '0', left: '0', width: '100%', height: '100%',
  background: 'rgba(0,0,0,0.6)', display: 'none', flexDirection: 'column',
  justifyContent: 'center', alignItems: 'center', color: 'white', zIndex: '70'
});
pauseMenu.innerHTML = `
  <h2>Paused</h2>
  <button id="resumeBtn">Resume</button>
  <button id="backToStartBtn">Back to Start</button>
`;
document.body.appendChild(pauseMenu);

// Mute logic
muteBtn.onclick = () => {
  muted = !muted;
  muteBtn.textContent = muted ? 'üîà' : 'üîá';
  document.querySelectorAll('audio').forEach(a => { try { a.muted = muted; } catch(e){} });
  if (muted) {
    if (currentBgm && !currentBgm.paused) { try { currentBgm.pause(); } catch(e){} }
  } else {
    if (currentBgm && running && !paused) { try { currentBgm.play().catch(()=>{}); } catch(e){} }
    else if (running && !currentBgm) { try { playRandomBgm(); } catch(e){} }
  }
};

// Pause / resume / back-to-start
pauseBtn.onclick = () => {
  if (!paused) {
    paused = true;
    pauseMenu.style.display = 'flex';
    if (currentBgm) currentBgm.pause();
  }
};
pauseMenu.querySelector('#resumeBtn').onclick = () => {
  paused = false;
  pauseMenu.style.display = 'none';
  if (currentBgm) currentBgm.play().catch(() => {});
};
pauseMenu.querySelector('#backToStartBtn').onclick = () => {
  paused = false;
  pauseMenu.style.display = 'none';
  if (currentBgm) { try { currentBgm.pause(); } catch(e){} }
  try { muteBtn.style.display = 'none'; } catch(e){}
  try { pauseBtn.style.display = 'none'; } catch(e){}
  toStart();
};

// Show Pause when game starts - single reliable binding
startButton.addEventListener('click', () => {
  try { pauseBtn.style.display = 'block'; } catch(e){}
  try { muteBtn.style.display = 'block'; } catch(e){}
  beginRecording();
  startGame();
});

// retry / toStart
retryButton.addEventListener('click', () => { try { pauseBtn.style.display = 'block'; } catch(e){} try { muteBtn.style.display = 'block'; } catch(e){} beginRecording(); restart(); });
toStartButton.addEventListener('click', () => { muteBtn.style.display = 'none'; pauseBtn.style.display = 'none'; toStart(); });

// ---------- Leaderboard client logic ----------
const API_BASE = 'https://chog-leaderboard-server.onrender.com'; // <-- set your server URL here

// recording state
let eventLog = [];
let runStartTs = 0;
let sessionRecording = false;

function beginRecording() {
  eventLog = [];
  runStartTs = performance.now();
  sessionRecording = true;
  resetSubmitStateForNewRun();
}
function stopRecording(){ sessionRecording = false; }
function recordMove(){
  try {
    if (!sessionRecording) return;
    eventLog.push({ t: Math.round(performance.now() - runStartTs), type: 'move', lane: player.lane });
  } catch(e){ }
}

// submit state helpers
function resetSubmitStateForNewRun() {
  submittedThisRun = false;
  submitInProgress = false;
  const btn = document.getElementById('submitScoreBtn');
  const msg = document.getElementById('submitMsg');
  const wrap = document.getElementById('submitWrap');
  if (btn) { btn.disabled = false; btn.textContent = "Submit"; }
  if (msg) { msg.style.display = "none"; msg.textContent = ""; }
  if (wrap) { wrap.style.display = "none"; }
}

// submit function (POST)
async function submitRunToServer() {
  if (submittedThisRun || submitInProgress) return;
  const nameEl = document.getElementById('leaderName');
  const msgEl = document.getElementById('submitMsg');
  if (!nameEl) return alert('Name input missing');
  const name = nameEl.value.trim();
  msgEl.style.display = 'block'; msgEl.textContent = 'Validating...';
  if (!name || name.length < 2) { msgEl.textContent = 'Name too short'; return; }
  if (name.length > 20) { msgEl.textContent = 'Name too long'; return; }

  const payload = {
    name: name,
    claimedScore: typeof coinCount !== 'undefined' ? coinCount : 0,
    runMs: Math.round(typeof elapsed !== 'undefined' ? elapsed : (performance.now() - runStartTs)),
    events: eventLog
  };

  msgEl.textContent = 'Submitting...';
  submitInProgress = true;
  const btn = document.getElementById('submitScoreBtn');
  if (btn) { btn.disabled = true; btn.textContent = 'Submitting...'; }
  try {
    const res = await fetch(API_BASE + '/api/submit', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(payload)
    });
    const j = await res.json();
    if (res.ok && j.ok) {
      msgEl.textContent = 'Submitted ‚úÖ';
      submittedThisRun = true;
      if (btn) { btn.disabled = true; btn.textContent = 'Submitted'; }
      loadLeaderboard();
    } else {
      msgEl.textContent = j.error || j.reason || 'Rejected';
      if (btn) { btn.disabled = false; btn.textContent = 'Submit'; }
    }
  } catch (err) {
    console.error(err);
    msgEl.textContent = 'Network error';
    if (btn) { btn.disabled = false; btn.textContent = 'Submit'; }
  } finally {
    submitInProgress = false;
  }
}

// load leaderboard
async function loadLeaderboard(limit = 8) {
  const box = document.getElementById('leaderboardRows');
  if (!box) return;
  box.innerHTML = 'Loading...';
  try {
    const r = await fetch(API_BASE + '/api/leaderboard?limit=' + limit);
    const j = await r.json();
    const rows = j.rows || j;
    if (!rows || rows.length === 0) { box.innerHTML = '<div style="opacity:.7">No scores yet</div>'; return; }
    box.innerHTML = rows.map((row,i)=>`<div style="margin-bottom:6px;"><strong>${i+1}.</strong> ${escapeHtml(row.name||row.username||row.name)} <span style="float:right;">${row.score}</span></div>`).join('');
  } catch(e){
    console.error(e);
    box.innerHTML = 'Failed to load';
  }
}
function escapeHtml(s){ return String(s).replace(/[&<>"']/g, c=>({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[c])); }

// wire submit button
const submitBtn = document.getElementById('submitScoreBtn');
if (submitBtn) submitBtn.addEventListener('click', submitRunToServer);
const sw = document.getElementById('submitWrap');
if (sw) sw.style.display = 'none';

// wrap toStart to refresh leaderboard and hide submit UI
const _origToStart = typeof toStart === 'function' ? toStart : null;
toStart = function(){
  if (_origToStart) _origToStart();
  const sw2 = document.getElementById('submitWrap'); if (sw2) sw2.style.display = 'none';
  loadLeaderboard();
};

// End game wrapper to stop recording & show submit
if (typeof endGame === 'function') {
  const _eg = endGame;
  endGame = function(){
    stopRecording();
    _eg();
    const sw3 = document.getElementById('submitWrap'); if (sw3 && !submittedThisRun) sw3.style.display = 'block';
    try { document.getElementById('leaderName').focus(); } catch(e){}
  }
}

// initial load of leaderboard
try { loadLeaderboard(); } catch(e){}

// Debug Access
window.ChogRush = { startGame, restart, toStart, getState: () => ({ coinCount, lives, entities, elapsed }) };

})();
</script>
</body>
</html>
